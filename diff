diff --git a/src/Exceptions.hpp b/src/Exceptions.hpp
index 0c527ea..d62c7e9 100644
--- a/src/Exceptions.hpp
+++ b/src/Exceptions.hpp
@@ -112,5 +112,6 @@ namespace Exceptions
 	public:
 		const char	*what(void) const throw();
 	};
+}
 
 #endif
diff --git a/src/InputHandler.cpp b/src/InputHandler.cpp
index 10a5554..42b192c 100644
--- a/src/InputHandler.cpp
+++ b/src/InputHandler.cpp
@@ -1,4 +1,6 @@
 #include "InputHandler.hpp"
+#include "Exceptions.hpp"
+#include "Parser.hpp"
 
 InputHandler::InputHandler(void) {
 	this->_vmStack = new VmStack();
@@ -15,8 +17,8 @@ InputHandler::InputHandler(void) {
 	this->_cmnd["mul"] = &VmStack::mul;
 	this->_cmnd["div"] = &VmStack::div;
 	this->_cmnd["mod"] = &VmStack::mod;
-	this->_cmnd["push"] = &VmStack::push;
-	this->_cmnd["assert"] = &VmStack::assert;
+	this->_cmndWithArg["push"] = &VmStack::push;
+	this->_cmndWithArg["assert"] = &VmStack::assert;
 }
 
 InputHandler::~InputHandler(void) {}
@@ -25,11 +27,11 @@ InputHandler::InputHandler(InputHandler const &oth) {
 	*this = oth;
 }
 
-InputHandler InputHandler::&operator=(InputHandler const &oth) {
+InputHandler &InputHandler::operator=(InputHandler const &oth) {
 	if (this != &oth) {
 		*this = oth;
 	}
-	return oth;
+	return *this;
 }
 
 void InputHandler::readFile(char *fname) {
@@ -38,9 +40,9 @@ void InputHandler::readFile(char *fname) {
     std::list<std::string> content;
     Parser prs;
 
-    ifs.open(fileName);
+    ifs.open(fname);
     if (!ifs.is_open()) {
-    	throw(FileErrException());
+    	throw(Exceptions::FileErrException());
     }
 
     while (std::getline(ifs, s)){
@@ -61,10 +63,10 @@ void InputHandler::readFile(char *fname) {
 		// catch (const UnknownCommandException &e) {
 		// 	std::cerr << e.what() << std::endl;
 		// }
-		catch (const SyntaxErrException &e) {
+		catch (const Exceptions::SyntaxErrException &e) {
 			std::cerr << e.what() << std::endl;
 		}
-		catch (const CommandAftExitException &e) {
+		catch (const Exceptions::CmndAftExitException &e) {
 			std::cerr << e.what() << std::endl;
 		}
 		catch (const std::exception &e) {
@@ -93,46 +95,86 @@ void InputHandler::readStdin(void) {
 		// catch (const UnknownCommandException &e) {
 		// 	std::cerr << e.what() << std::endl;
 		// }
-		catch (const SyntaxErrException &e) {
+		catch (const Exceptions::SyntaxErrException &e) {
 			std::cerr << e.what() << std::endl;
 		}
-		catch (const CommandAftExitException &e) {
+		catch (const Exceptions::CommandAftExitException &e) {
 			std::cerr << e.what() << std::endl;
 		}
 		catch (const std::exception &e) {
 			std::cerr << e.what() << std::endl;
 		}
-		if (prs._match[CMD_ID] != CMD_EXIT) {
-			this->calcExpression(prs._match);
+		if (prs.getCmnd() != CMD_EXIT) {
+			this->calcExpression(prs.getCmnd());
 		}
 	}
 }
 
 
-void calcExpression(std::cmatch const &_match) {
-	if (_match[CMD_ID] == "CMD_PUSH" || _match[CMD_ID] == "CMD_ASSERT") {
-        IOperand const *op = _factory.createOperand(_match[TYP_ID], _match[VAL_ID]);
-     	try {
-        	_abstractStack->*(this->_cmnd[command.getContent()])(op);
-     	}
-	} else {
-		try {
-			this->_vmStack->*(_match[CMD_ID]);
-		}
-	}
-    catch (const EmptyStackException& e) {
+// void calcExpression(std::cmatch const &_match) {
+// 	if (_match[CMD_ID] == "CMD_PUSH" || _match[CMD_ID] == "CMD_ASSERT") {
+//         IOperand const *op = _factory.createOperand(_match[TYP_ID], _match[VAL_ID]);
+//      	try {
+//         	_abstractStack->*(this->_cmnd[command.getContent()])(op);
+//      	}
+// 	} else {
+// 		try {
+// 			this->_vmStack->*(_match[CMD_ID]);
+// 		}
+// 	}
+//     catch (const Exceptions::EmptyStackException& e) {
+//     	std::cerr << e.what() << std::endl; 
+//     }
+//     catch (const Exceptions::UnderFlowException& e) {
+//     	std::cerr << e.what() << std::endl; 
+//     }
+//     catch (const Exceptions::OverFlowException& e) {
+//     	std::cerr << e.what() << std::endl; 
+//     }
+//     catch (const Exceptions::AssertFailException& e) {
+//     	std::cerr << e.what() << std::endl; 
+//     }
+//     catch (const std::exception& e) {
+//     	std::cerr << e.what() << std::endl; 
+//     }
+// }
+
+void calcExpression(std::string const &cmnd) {
+	try {
+        	this->_vmStack->*_cmnd[cmnd]();
+    } catch (const Exceptions::EmptyStackException& e) {
     	std::cerr << e.what() << std::endl; 
     }
-    catch (const UnderFlowException& e) {
+    catch (const Exceptions::UnderFlowException& e) {
     	std::cerr << e.what() << std::endl; 
     }
-    catch (const OverFlowException& e) {
+    catch (const Exceptions::OverFlowException& e) {
     	std::cerr << e.what() << std::endl; 
     }
-    catch (const AssertFailException& e) {
+    catch (const Exceptions::AssertFailException& e) {
     	std::cerr << e.what() << std::endl; 
     }
     catch (const std::exception& e) {
     	std::cerr << e.what() << std::endl; 
     }
 }
+
+void calcExpression(std::string const &cmnd, IOperand const *rhs) {
+	try {
+        	this->_vmStack->*_cmnd[cmnd](rhs);
+    } catch (const Exceptions::EmptyStackException& e) {
+    	std::cerr << e.what() << std::endl; 
+    }
+    catch (const Exceptions::UnderFlowException& e) {
+    	std::cerr << e.what() << std::endl; 
+    }
+    catch (const Exceptions::OverFlowException& e) {
+    	std::cerr << e.what() << std::endl; 
+    }
+    catch (const Exceptions::AssertFailException& e) {
+    	std::cerr << e.what() << std::endl; 
+    }
+    catch (const std::exception& e) {
+    	std::cerr << e.what() << std::endl; 
+    }
+}
\ No newline at end of file
diff --git a/src/InputHandler.hpp b/src/InputHandler.hpp
index 227d4ec..55d5f51 100644
--- a/src/InputHandler.hpp
+++ b/src/InputHandler.hpp
@@ -1,17 +1,20 @@
 #ifndef INPUTHANDLER_HPP
 #define INPUTHANDLER_HPP
 
-#include <iostream>
+// #include <iostream>
+#include <fstream>
 #include <map>
 #include <string>
 #include <list>
+// #include <regex>
 #include "VmStack.hpp"
 
 class InputHandler
 {
 private:
-	VmStack											*_vmStack;
-	std::map<std::string, void (VmStack::*)()>		_cmnd;
+	VmStack										*_vmStack;
+	std::map<std::string, void (VmStack::*)()>	_cmnd;
+	std::map<std::string, void (VmStack::*)(const IOperand *)>	_cmndWithArg;
 	// std::map<std::string, eOperandType>		_types;
 
 public:
@@ -22,7 +25,8 @@ public:
 
 	void readFile(char *fname);
 	void readStdin(void);
-	void calcExpression(std::cmatch const &_match);
-}
+	void calcExpression(std::string const &cmnd);
+	void calcExpression(std::string const &cmnd, IOperand const *rhs);
+};
 
 #endif
\ No newline at end of file
diff --git a/src/IterableStack.hpp b/src/IterableStack.hpp
index 59b326d..9368259 100644
--- a/src/IterableStack.hpp
+++ b/src/IterableStack.hpp
@@ -5,12 +5,12 @@
 #include <stack>
 
 template <typename T>
-class ItarbleStack : public std::stack<T> {
+class IterableStack : public std::stack<T> {
 	public:
-		ItarbleStack(): std::stack<T>() {}
-		ItarbleStack(std::stack<T> const &oth): std::stack<T>(oth) {}
-		ItarbleStack(ItarbleStack const &oth): std::stack<T>(oth) {}
-		virtual ~ItarbleStack() {}
+		IterableStack(): std::stack<T>() {}
+		IterableStack(std::stack<T> const &oth): std::stack<T>(oth) {}
+		IterableStack(IterableStack const &oth): std::stack<T>(oth) {}
+		virtual ~IterableStack() {}
 		using std::stack<T>::operator=;
 		typedef typename std::stack<T>::container_type::iterator iterator;
 		iterator begin() {
diff --git a/src/Operand.hpp b/src/Operand.hpp
index 48f4898..cb6ef52 100644
--- a/src/Operand.hpp
+++ b/src/Operand.hpp
@@ -4,6 +4,8 @@
 #include "IOperand.hpp"
 #include "FactoryClass.hpp"
 #include "Exceptions.hpp"
+#include <cmath>
+
 
 template<typename T>
 class Operand : public IOperand
@@ -50,10 +52,12 @@ public:
 	IOperand const *operator*(IOperand const &rhs) const;
 	IOperand const *operator/(IOperand const &rhs) const;
 	IOperand const *operator%(IOperand const &rhs) const;
-
+	bool operator==(IOperand const &rhs) const;
+	bool operator>(IOperand const &rhs) const;
+	bool operator<(IOperand const &rhs) const;
 };
 
-#define HIGHER_PRECISION_TYPE(a, b) ((a.getPrecision()) >= (b.getPrecision()) ? (a.getType()) : (b.getType()))
+#define HIGHER_PRECISION_TYPE(a, b) ((a).getPrecision() >= (b).getPrecision() ? (a).getType() : (b).getType())
 template<typename T>
 IOperand const *Operand<T>::operator+(IOperand const &rhs) const {
 		long double rhsVal = std::stold(rhs.toString());
@@ -63,6 +67,7 @@ IOperand const *Operand<T>::operator+(IOperand const &rhs) const {
 				+ rhsVal)));
 }
 
+template<typename T>
 IOperand const *Operand<T>::operator-(IOperand const &rhs) const {
 		long double rhsVal = std::stold(rhs.toString());
 		eOperandType newType = HIGHER_PRECISION_TYPE(*this, rhs);
@@ -71,6 +76,7 @@ IOperand const *Operand<T>::operator-(IOperand const &rhs) const {
 				- rhsVal)));
 }
 
+template<typename T>
 IOperand const *Operand<T>::operator*(IOperand const &rhs) const {
 		long double rhsVal = std::stold(rhs.toString());
 		eOperandType newType = HIGHER_PRECISION_TYPE(*this, rhs);
@@ -79,6 +85,7 @@ IOperand const *Operand<T>::operator*(IOperand const &rhs) const {
 				* rhsVal)));
 }
 
+template<typename T>
 IOperand const *Operand<T>::operator/(IOperand const &rhs) const {
 		long double rhsVal = std::stold(rhs.toString());
 		if (rhsVal == 0)
@@ -90,6 +97,7 @@ IOperand const *Operand<T>::operator/(IOperand const &rhs) const {
 				/ rhsVal)));
 }
 
+template<typename T>
 IOperand const *Operand<T>::operator%(IOperand const &rhs) const {
 		long double rhsVal = std::stold(rhs.toString());
 		if (rhsVal == 0)
@@ -97,32 +105,32 @@ IOperand const *Operand<T>::operator%(IOperand const &rhs) const {
 
 		eOperandType newType = HIGHER_PRECISION_TYPE(*this, rhs);
 
-		return (_factory.createOperand(newType, std::to_string(static_cast<long double>(_value)
-				% rhsVal)));
+		return (_factory.createOperand(newType, std::to_string(fmod(static_cast<long double>(_value),
+				rhsVal))));
 }
 
 // ------------------------- Comparison Operators -------------------------
 // CHECK + ADD NEW
 
+template<typename T>
 bool	Operand<T>::operator==(IOperand const &rhs) const {
 		long double rhsVal = std::stold(rhs.toString());
-		eOperandType newType = HIGHER_PRECISION_TYPE(*this, rhs);
 
 		return static_cast<long double>(_value) == rhsVal;
 }
 
+template<typename T>
 bool	Operand<T>::operator>(IOperand const &rhs) const {
 		long double rhsVal = std::stold(rhs.toString());
-		eOperandType newType = HIGHER_PRECISION_TYPE(*this, rhs);
 
-		return static_cast<long double>(_value) > std::stod(rhs.toString());
+		return static_cast<long double>(_value) > rhsVal;
 }
 
+template<typename T>
 bool	Operand<T>::operator<(IOperand const &rhs) const {
 		long double rhsVal = std::stold(rhs.toString());
-		eOperandType newType = HIGHER_PRECISION_TYPE(*this, rhs);
 
-		return static_cast<long double>(_value) < std::stod(rhs.toString());
+		return static_cast<long double>(_value) < rhsVal;
 }
 
-
+#endif
\ No newline at end of file
diff --git a/src/Parcer.cpp b/src/Parcer.cpp
index 454ab2f..4fe4f56 100644
--- a/src/Parcer.cpp
+++ b/src/Parcer.cpp
@@ -46,4 +46,14 @@ void processLine(std::string s) {
 void Parser::isExit() {
     if (!this->_isExit)
         throw NoExitException();
+}
+
+std::string &Parser::getCmnd() {
+	return _match[CMD_ID];
+}
+
+IOperand *Parser::getValue() {
+	if (_match.size() == VAL_ID)
+		return _factory.createOperand(_match[TYP_ID], _match[VAL_ID]);
+	return NULL;
 }
\ No newline at end of file
diff --git a/src/Parser.hpp b/src/Parser.hpp
index 8487d2b..f4a1734 100644
--- a/src/Parser.hpp
+++ b/src/Parser.hpp
@@ -5,7 +5,7 @@
 #include <iostream>
 #include <stack>
 #include <regex>
-#include "Ioperadn.hpp"
+#include "IOperand.hpp"
 
 class Parser
 {
@@ -27,6 +27,8 @@ public:
 	Parser &operator=(Parser const &oth);
 
 	void processLine(std::string s);
+	std::string &getCmnd();
+	IOperand *getValue();
 
 	void isExit();
 	// void executeTokens(Token command);
